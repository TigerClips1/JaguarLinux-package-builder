#!/usr/bin/perl

use strict;
use warnings;
use autodie qw(:all);
use feature qw(:5.14);
use LWP::UserAgent;
use LWP::ConnCache;
use JSON;
use URI;
use Text::Wrap qw(wrap $columns);
use File::Basename qw(dirname);

our $packager = '';
my %pkgmap = ();
my %licenses = ();

my $template = <<'EOF';
# Automatically generated by ps4build-pypi, template 4
[% authors %]
pkgname=[% pkgname %]
pkgver=[% pkgver %]
pkgrel=[% pkgrel %]
#_pkgreal is used by ps4build-pypi to find modules at PyPI
_pkgreal=[% pkgreal %]
pkgdesc="[% pkgdesc %]"
url="[% url %]"
arch="noarch"
license="[% license %]"
depends=""
makedepends="py3-gpep517 py3-setuptools py3-wheel"
checkdepends="py3-pytest"
subpackages="$pkgname-pyc"
source="[% source %]"
builddir="[% builddir %]"
options="[% options %]"[% options_comment %]
[% compatibility %]
build() {
	gpep517 build-wheel \
		--wheel-dir .dist \
		--output-fd 3 3>&1 >&2
}

check() {
	python3 -m venv --clear --without-pip --system-site-packages .testenv
	.testenv/bin/python3 -m installer .dist/*.whl
	.testenv/bin/python3 -m pytest
}

package() {
	python3 -m installer -d "$pkgdir" \
		.dist/*.whl
}

EOF

my $ua = LWP::UserAgent->new();
my $json = JSON->new;
$ua->env_proxy;
$ua->conn_cache(LWP::ConnCache->new);

sub read_file {
    my ($filename) = @_;
    open my $fh, '<:utf8', $filename;
    local $/;
    my $text = <$fh>;
    return $text;
}

sub read_assignments_from_file {
    my ($filename) = @_;
    return () if ( ! -e $filename );
    my $text = read_file($filename);
    my %sline = $text =~ /^(\w+)\s*=\s*([^\"\n]*)$/mg;
    my %mline = $text =~ /^(\w+)\s*=\s*\"([^\"]*)\".*$/mg;
    my %hash = ( %sline, %mline );

    return \%hash if $filename ne 'PS4BUILD';
    my $authors = join( "\n",
        $text =~ /^# Contributor: .*$/mg,
        $text =~ /^# Maintainer: .*$/mg );
    $hash{'authors'} = $authors if length($authors) > 1;

    if ($text =~ m/^provides=\"(.*)\"(.*)$/m) {
        $hash{'provides'} = $1;
        $hash{'provides_comment'} = $2;
    }

    if ($text =~ m/^replaces=\"(.*)\"(.*)$/m) {
        $hash{'replaces'} = $1;
        $hash{'replaces_comment'} = $2;
    }

    # workaround for `builddir="$srcdir"/$_pkgname-$pkgver`
    if ($text =~ m/^builddir=\"(.*)\"([^\s]*)/m) {
        $hash{'builddir'} = $1 . $2;
    }

    if ($text =~ m/^options=\"(.*)\"(.*)$/m) {
        $hash{'options'} = $1;
        $hash{'options_comment'} = $2;
    }

    return \%hash;
}

sub map_pypi_to_ps4 {
    my ($pypi) = @_;
    return $pkgmap{$pypi} unless !exists($pkgmap{$pypi});
    return 'py3-'.lc($pypi);
}

sub map_license {
    my ($license) = @_;

    $license //= '';
    $license =~ s/ or / /g;

    return $license;
}

sub get_source {
    my ($distdata) = @_;
    my $pkgname = $distdata->{info}{name};

    my $source;
    for my $url (@{$distdata->{urls}}) {
        if ($url->{python_version} eq 'source') {
            $source = URI->new($url->{url});
            last;
        }
    }
    die "Unable to locate sources for $pkgname.\n" unless $source;

    my $filename = ($source->path_segments)[-1];
    my $pretty_path = substr($pkgname, 0, 1) . "/$pkgname";
    my $pretty_url = $source->clone;
    $pretty_url->path("/packages/source/$pretty_path/$filename");

    my $response = $ua->head($pretty_url);
    if ($response->is_success) {
        return $pretty_url->as_string;
    } else {
        return $source->as_string;
    }
}

sub read_ps4build {
    return read_assignments_from_file('PS4BUILD');
}

sub format_line {
    my $line = shift;
    return "\t" . $line . "\n";
}

sub format_source {
    my $srcurl   = shift;
    my $orig_src = shift;

    $orig_src =~ s/^\s+//mg;
    $orig_src =~ s/\s+/ /g;

    my @sources = split (/\s/, $orig_src);

    return $srcurl if @sources <= 1;

    shift @sources if $sources[0] =~ m/pkgver/;
    my $patches;
    for my $patch (@sources) {
        next if $patch eq "";
        $patches .= format_line($patch);
    }

    return $srcurl . "\n" . ($patches // '') . "\t";
}

sub write_ps4build {
    my ($distdata, $ps4build) = @_;

    my $replaces = undef;
    my $provides = undef;
    my $authors = undef;
    my $license = undef;
    my $url = undef;
    my $pkgname = undef;
    my $pkgdesc = undef;
    my $pkgrel = 0;
    my $builddir = undef;
    my $options = undef;
    my $options_comment = undef;
    my $orig_source = "";

    if (our $use_homepage) {
        $url =
          $distdata->{info}{project_urls}{Homepage}
          || $distdata->{info}{home_page};
    }

    if (defined $ps4build) {
        $authors = $ps4build->{authors};
        $provides = $ps4build->{provides};
        $replaces = $ps4build->{replaces};
        $license = $ps4build->{license};
        $url = $ps4build->{url};
        $pkgname = $ps4build->{pkgname};
        $pkgdesc = $ps4build->{pkgdesc};
        $pkgrel = $ps4build->{pkgrel};
        $builddir = $ps4build->{builddir};
        $options  = $ps4build->{options} if defined $ps4build->{options};
        $options_comment  = $ps4build->{options_comment} if defined $ps4build->{options_comment};
        $orig_source      = $ps4build->{source};

	if ($ps4build->{pkgver} eq $distdata->{info}{version}) {
	    $pkgrel++;
	}
    }

    my $pkgreal = $distdata->{info}{name};
    my $srcurl = get_source($distdata);

    my %repl = (
	authors  => ($authors or "# Contributor: $packager\n# Maintainer: $packager"),
        pkgname  => ($pkgname or map_pypi_to_ps4($pkgreal)),
        pkgreal  => $pkgreal,
        pkgver   => $distdata->{info}{version},
        pkgrel	 => $pkgrel,
        source   => format_source($srcurl, $orig_source),
        license  => ($license or map_license($distdata->{info}{license})),
        url      => ($url or "https://pypi.org/project/${pkgreal}/"),
        pkgdesc  => ($pkgdesc or $distdata->{info}{summary} or "Python module for $pkgreal"),
        builddir => ($builddir or ''),
        options  => ($options or ''),
        options_comment => ($options_comment or ''),
    );

    $repl{compatibility} = "";
    if ($replaces) {
        my $comment = $ps4build->{'replaces_comment'} // '';
        $repl{compatibility} .= "\nreplaces=\"$replaces\"" . $comment;
    }
    if ($provides) {
        my $comment = $ps4build->{'provides_comment'} // '';
        $repl{compatibility} .= "\nprovides=\"$provides\"" . $comment;
    }
    $repl{compatibility} .= "\n" if $replaces or $provides;

    $repl{source} =~ s/-$repl{pkgver}/-\$pkgver/g;
    $template =~ s/\[% (.*?) %\]/$repl{$1}/g;

    open my $fh, '>:utf8', 'PS4BUILD';
    print {$fh} $template;
    close $fh;

    say "Wrote $repl{pkgname}/PS4BUILD";

    return \%repl;
}

sub unpack_source {
    system('pbuild checksum unpack');
}

sub prepare_tree {
    my %options = @_;

    unpack_source if $options{unpack};
    system('pbuild prepare');
}

sub find_package_name {
    my ($ps4build) = @_;

    my $pkgreal = '';

    if (exists $ps4build->{_realname}) {
        $pkgreal = $ps4build->{_realname};
    } elsif (exists $ps4build->{_pkgreal}) {
        $pkgreal = $ps4build->{_pkgreal};
    } elsif (exists $ps4build->{_pkgname}) {
        $pkgreal = $ps4build->{_pkgname};
    } elsif (exists $ps4build->{_name}) {
        $pkgreal = $ps4build->{_name};
    } elsif (exists $ps4build->{_realpkgname}) {
        $pkgreal = $ps4build->{_realpkgname};
    } elsif (exists $ps4build->{_pkg_real}) {
        $pkgreal = $ps4build->{_pkg_real};
    } elsif (exists $ps4build->{source}) {
        $pkgreal = $ps4build->{source};
        $pkgreal =~ m/(\w+)-/;
        $pkgreal = $1;
    } else {
        print "No pkg real found\n";
        die;
    }
    return $pkgreal;
}

sub get_data {
    my ($package) = @_;
    my $response = $ua->get("https://pypi.org/pypi/$package/json");
    $response->is_success or die $response->status_line;
    my $distdata = $json->decode($response->decoded_content);

    return $distdata;
}

sub parse_requires_dist {
    my $reqs = shift;

    # Valid PyPI regex: https://peps.python.org/pep-0508/#names
    my $pypi_regex = qr/(?i)([A-Z0-9][A-Z0-9][A-Z0-9._-]*[A-Z0-9])/;

    my @depends =
        map { m/$pypi_regex/; $1 || () }
        grep { $_ !~ m/; extra ==/ }
        @$reqs;

    my @checkdeps =
        map { m/$pypi_regex/; $1 || () }
        grep { m/; extra == ["'](tests|pytest)["']/ }
        @$reqs;

    my %reqs = (
	depends    => \@depends,
	checkdeps  => \@checkdeps,
    );

    return \%reqs;
}

sub format_depends {
    my $deps = shift;

    $columns = 102;

    $deps =~ s/ {2,}/ /g;
    $deps =~ s/^\s//g;
    $deps =~ s/\s$//g;

    if ( length($deps) >= $columns ) {
        $deps = wrap( "\t", "\t", $deps );
    }
    $deps =~ s/\s$//g;

    if ( length($deps) >= $columns ) {
        $deps = "\n" . $deps . "\n\t";
    }
    return $deps;
}

sub get_deps {
    my ($distdata, $data) = @_;

    my $reqs = parse_requires_dist($distdata->{info}{requires_dist});
    my %depends = ('py3-pytest' => 'py3-pytest');

    my @depends =
        map {
            my $ps4name = map_pypi_to_ps4($_);
            if (exists $depends{$ps4name}) { () }
            else { $depends{$ps4name} = $ps4name }
        }
        @{$reqs->{depends}};

    my @checkdeps =
        map {
            my $ps4name = map_pypi_to_ps4($_);
            exists($depends{$ps4name}) ? () : $ps4name
        }
        @{$reqs->{checkdeps}};

    my $ps4 = read_file('PS4BUILD');

    my $depends = format_depends(join ' ', @depends);

    $ps4 =~ s/^depends=""/depends="$depends"/m;

    unshift @checkdeps, 'py3-pytest';
    my $checkdeps = format_depends(join ' ', @checkdeps);

    $ps4 =~ s/^checkdepends="py3-pytest"/checkdepends="$checkdeps"/m;

    # remove empty variables
    $ps4 =~ s/.*="".{0,}\n//g;

    open my $fh, '>:utf8', 'PS4BUILD';

    print $fh $ps4;

    say "Requires: @depends\n\nCheckDepends: @checkdeps";
}

sub write_old_deps {
    my ($data, $ps4build) = @_;

    my $ps4 = read_file('PS4BUILD');

    if (my $depends = $ps4build->{depends}) {
        $ps4 =~ s/^depends=".*"/depends="$depends"/m;
    }

    if (my $makedeps = $ps4build->{makedepends}) {
        if ($makedeps =~ m/py3-gpep517/) {
           $ps4 =~ s/^makedepends=".*"/makedepends="$makedeps"/m;
        } else {
           $ps4 =~ s/^makedepends="(.*)"/makedepends="$1 $makedeps"/m;
        }
    }

    if (my $checkdeps = $ps4build->{checkdepends}) {
        if ($checkdeps =~ m/py3-pytest/) {
            $ps4 =~ s/^checkdepends=".*"/checkdepends="$checkdeps"/m;
        } else {
            $ps4 =~ s/^checkdepends="(.*)"/checkdepends="$1 $checkdeps"/m;
        }
    }

    # remove empty variables
    $ps4 =~ s/.*="".{0,}\n//g;

    open my $fh, '>:utf8', 'PS4BUILD';

    print $fh $ps4;
}

sub update_builddir {
    my $ps4build = read_ps4build;
    my $pkgreal = $ps4build->{'_pkgreal'};
    my $pkgname = $ps4build->{pkgname};
    my $pkgver = $ps4build->{pkgver};
    my $oldbuilddir = $ps4build->{builddir};

    my $build_path = glob("
      src/*${pkgver}/pyproject.toml
      src/*${pkgver}/setup.py
    ");

    if ($build_path) {
        my $newbuilddir = dirname($build_path);

        $newbuilddir =~ s/src/\$srcdir/;
        $newbuilddir =~ s/$pkgreal/\$_pkgreal/;
        $newbuilddir =~ s/$pkgver/\$pkgver/;

        my $ps4 = read_file('PS4BUILD');

        if ($pkgname eq $pkgreal and
          $newbuilddir eq '$srcdir/$_pkgreal-$pkgver') {
            # this will be deleted by the remove empty
            # variables regex in get_deps/write_old_deps
            $ps4 =~ s/^builddir=".*"/builddir=""/m;

            $newbuilddir = '<same as default, deleted>';
        } elsif ($newbuilddir eq $oldbuilddir) {
            return;
        } else {
            $ps4 =~ s/^builddir=".*"/builddir="$newbuilddir"/m;
        }

        print "\n\$builddir redefined:\n\t",
            "OLD: $oldbuilddir, NEW: $newbuilddir\n\n";

        open my $fh, '>:utf8', 'PS4BUILD';
        print $fh $ps4;
    }
}

my $pbuild_conf = read_assignments_from_file('/etc/pbuild.conf');
$packager = $pbuild_conf->{PACKAGER} if $pbuild_conf->{PACKAGER};

my $user_pbuild_conf = read_assignments_from_file($ENV{"HOME"} . "/.pbuild/pbuild.conf");
$packager = $user_pbuild_conf->{PACKAGER} if $user_pbuild_conf->{PACKAGER};

sub usage {
    say <<'EOF';
Usage: ps4build-pypi [create <package> [homepage] | check | recreate [deps] | upgrade | update]

In the repository root:
    create <package>: Creates an ps4BUILD for <package>
    create <package> homepage: Creates an ps4BUILD for <package> with url= field set to project homepage, if available

In the package root:
    check           : Reports current & latest version of the package
    recreate [deps] : Recreates the ps4BUILD [also recalculate dependencies]
    upgrade         : Upgrades to the latest version of the package
    update          : Updates ps4BUILD metadata
EOF
}

if (! defined $ARGV[0]) {
    die usage;
} elsif ($ARGV[0] eq 'create') {
    my $package = $ARGV[1];
    $package or die usage;

    my $distdata = get_data($package);
    my $ps4name = map_pypi_to_ps4($package);

    mkdir $ps4name;
    chdir $ps4name;

    if ($ARGV[2] and $ARGV[2] eq 'homepage') { our $use_homepage = 1; }

    my $data = write_ps4build($distdata, undef);
    unpack_source;
    update_builddir;

    get_deps($distdata, $data);
    prepare_tree( unpack => 0 );
} elsif ($ARGV[0] eq 'recreate') {
    my $ps4build = read_ps4build;
    if (! defined $ps4build->{_pkgreal}) {
        $ps4build->{_pkgreal} = find_package_name($ps4build);
    }
    my $distdata = get_data($ps4build->{_pkgreal});
    my $pkgver = $distdata->{info}{version} =~ s/^[^0-9]+//r;
    if ($pkgver ne $ps4build->{pkgver}) {
        #Reset pkgrel on upgrade on recreate
        say "Upgrading PyPI module from $ps4build->{pkgver} to $pkgver";
        $ps4build->{pkgrel}=0;
    }

    my $data = write_ps4build($distdata, $ps4build);
    unpack_source;
    update_builddir;

    if ($ARGV[1] and $ARGV[1] eq 'deps') { get_deps($distdata, $data); }
    else { write_old_deps($data, $ps4build); }
    prepare_tree( unpack => 0 );
} elsif ($ARGV[0] eq 'upgrade') {
    my $ps4build = read_ps4build;

    if (! defined $ps4build->{_pkgreal}) {
        $ps4build->{_pkgreal} = find_package_name($ps4build);
    }

    my $distdata = get_data($ps4build->{_pkgreal});

    my $pkgver = $distdata->{info}{version};

    if ($pkgver ne $ps4build->{pkgver}) {
        say "Upgrading PyPI package from $ps4build->{pkgver} to $pkgver";

        my $text = read_file('PS4BUILD');

        $text =~ s/^(pkgver)=.*$/$1=$pkgver/mg or
            die "Can't find pkgver line in PS4BUILD";
        $text =~ s/^(pkgrel)=.*$/$1=0/mg or
            die "Can't find pkgrel line in PS4BUILD";

        open my $fh, '>:utf8', 'PS4BUILD';
        print $fh $text;
        close $fh;
    } else {
        say "Already up to date with PyPI";
    }
} elsif ($ARGV[0] eq 'check') {
    my $ps4build = read_ps4build;

    if (! defined $ps4build->{_pkgreal}) {
        $ps4build->{_pkgreal} = find_package_name($ps4build);
    }
    my $distdata = get_data($ps4build->{_pkgreal});

    my $pkgver = $distdata->{info}{version};


    say "$ps4build->{pkgname}: Latest version: $pkgver Packaged version: $ps4build->{pkgver}";
    if ($pkgver ne $ps4build->{pkgver}) {
        exit(1);
    }
} elsif ($ARGV[0] eq 'update') {
    prepare_tree( unpack => 1 );
} else {
    die usage;
}
